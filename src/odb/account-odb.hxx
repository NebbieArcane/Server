// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef ACCOUNT_ODB_HXX
#define ACCOUNT_ODB_HXX

// Begin prologue.
//
#include <odb/boost/version.hxx>
#if ODB_BOOST_VERSION != 2040000 // 2.4.0
#  error ODB and C++ compilers see different libodb-boost interface versions
#endif
#include <boost/shared_ptr.hpp>
#include <odb/boost/smart-ptr/pointer-traits.hxx>
#include <odb/boost/smart-ptr/wrapper-traits.hxx>
//
// End prologue.

#include <odb/version.hxx>

#if (ODB_VERSION != 20400UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "account.hpp"

#include <memory>
#include <cstddef>
#include <utility>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#ifdef BOOST_TR1_MEMORY_HPP_INCLUDED
#  include <odb/tr1/wrapper-traits.hxx>
#  include <odb/tr1/pointer-traits.hxx>
#endif
#include <odb/container-traits.hxx>
#include <odb/session.hxx>
#include <odb/cache-traits.hxx>
#include <odb/query-dynamic.hxx>
#include <odb/prepared-query.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb
{
  // toonExtra
  //
  template <>
  struct class_traits< ::Alarmud::toonExtra >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Alarmud::toonExtra >
  {
    public:
    typedef ::Alarmud::toonExtra object_type;
    typedef ::boost::shared_ptr< ::Alarmud::toonExtra > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::std::string id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::Alarmud::toonExtra, id_common, A >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // classes
    //
    typedef odb::query_column< ::std::string > classes_type_;

    static classes_type_ classes;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::Alarmud::toonExtra, id_common, A >::name_type_
  query_columns< ::Alarmud::toonExtra, id_common, A >::name;

  template <typename A>
  typename query_columns< ::Alarmud::toonExtra, id_common, A >::classes_type_
  query_columns< ::Alarmud::toonExtra, id_common, A >::classes;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::Alarmud::toonExtra, id_common, A >:
    query_columns< ::Alarmud::toonExtra, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Alarmud::toonExtra, id_common >:
    public access::object_traits< ::Alarmud::toonExtra >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, const object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
      odb::details::shared_ptr<prepared_query_impl> (*prepare_query) (connection&, const char*, const query_base_type&);
      odb::details::shared_ptr<result_impl> (*execute_query) (prepared_query_impl&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  // toonRent
  //
  template <>
  struct class_traits< ::Alarmud::toonRent >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Alarmud::toonRent >
  {
    public:
    typedef ::Alarmud::toonRent object_type;
    typedef ::boost::shared_ptr< ::Alarmud::toonRent > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::std::string id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::Alarmud::toonRent, id_common, A >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // vnum
    //
    typedef odb::query_column< long unsigned int > vnum_type_;

    static vnum_type_ vnum;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::Alarmud::toonRent, id_common, A >::name_type_
  query_columns< ::Alarmud::toonRent, id_common, A >::name;

  template <typename A>
  typename query_columns< ::Alarmud::toonRent, id_common, A >::vnum_type_
  query_columns< ::Alarmud::toonRent, id_common, A >::vnum;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::Alarmud::toonRent, id_common, A >:
    query_columns< ::Alarmud::toonRent, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Alarmud::toonRent, id_common >:
    public access::object_traits< ::Alarmud::toonRent >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, const object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
      odb::details::shared_ptr<prepared_query_impl> (*prepare_query) (connection&, const char*, const query_base_type&);
      odb::details::shared_ptr<result_impl> (*execute_query) (prepared_query_impl&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  // toonBank
  //
  template <>
  struct class_traits< ::Alarmud::toonBank >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Alarmud::toonBank >
  {
    public:
    typedef ::Alarmud::toonBank object_type;
    typedef ::boost::shared_ptr< ::Alarmud::toonBank > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::std::string id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::Alarmud::toonBank, id_common, A >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // vnum
    //
    typedef odb::query_column< long unsigned int > vnum_type_;

    static vnum_type_ vnum;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::Alarmud::toonBank, id_common, A >::name_type_
  query_columns< ::Alarmud::toonBank, id_common, A >::name;

  template <typename A>
  typename query_columns< ::Alarmud::toonBank, id_common, A >::vnum_type_
  query_columns< ::Alarmud::toonBank, id_common, A >::vnum;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::Alarmud::toonBank, id_common, A >:
    query_columns< ::Alarmud::toonBank, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Alarmud::toonBank, id_common >:
    public access::object_traits< ::Alarmud::toonBank >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, const object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
      odb::details::shared_ptr<prepared_query_impl> (*prepare_query) (connection&, const char*, const query_base_type&);
      odb::details::shared_ptr<result_impl> (*execute_query) (prepared_query_impl&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  // toon
  //
  template <>
  struct class_traits< ::Alarmud::toon >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Alarmud::toon >
  {
    public:
    typedef ::Alarmud::toon object_type;
    typedef ::boost::shared_ptr< ::Alarmud::toon > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::std::string id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct data_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::Alarmud::toon, id_common, A >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // password
    //
    typedef odb::query_column< ::std::string > password_type_;

    static password_type_ password;

    // title
    //
    typedef odb::query_column< ::std::string > title_type_;

    static title_type_ title;

    // lastlogin
    //
    typedef odb::query_column< ::boost::posix_time::ptime > lastlogin_type_;

    static lastlogin_type_ lastlogin;

    // owner_id
    //
    typedef odb::query_column< long long unsigned int > owner_id_type_;

    static owner_id_type_ owner_id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::Alarmud::toon, id_common, A >::name_type_
  pointer_query_columns< ::Alarmud::toon, id_common, A >::name;

  template <typename A>
  typename pointer_query_columns< ::Alarmud::toon, id_common, A >::password_type_
  pointer_query_columns< ::Alarmud::toon, id_common, A >::password;

  template <typename A>
  typename pointer_query_columns< ::Alarmud::toon, id_common, A >::title_type_
  pointer_query_columns< ::Alarmud::toon, id_common, A >::title;

  template <typename A>
  typename pointer_query_columns< ::Alarmud::toon, id_common, A >::lastlogin_type_
  pointer_query_columns< ::Alarmud::toon, id_common, A >::lastlogin;

  template <typename A>
  typename pointer_query_columns< ::Alarmud::toon, id_common, A >::owner_id_type_
  pointer_query_columns< ::Alarmud::toon, id_common, A >::owner_id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::Alarmud::toon, id_common >:
    public access::object_traits< ::Alarmud::toon >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, const object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
      odb::details::shared_ptr<prepared_query_impl> (*prepare_query) (connection&, const char*, const query_base_type&);
      odb::details::shared_ptr<result_impl> (*execute_query) (prepared_query_impl&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  // user
  //
  template <>
  struct class_traits< ::Alarmud::user >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Alarmud::user >
  {
    public:
    typedef ::Alarmud::user object_type;
    typedef ::boost::shared_ptr< ::Alarmud::user > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::Alarmud::user, id_common, A >
  {
    // id
    //
    typedef odb::query_column< long long unsigned int > id_type_;

    static id_type_ id;

    // login
    //
    typedef odb::query_column< ::std::string > login_type_;

    static login_type_ login;

    // nickname
    //
    typedef odb::query_column< ::std::string > nickname_type_;

    static nickname_type_ nickname;

    // email
    //
    typedef odb::query_column< ::std::string > email_type_;

    static email_type_ email;

    // registered
    //
    typedef odb::query_column< ::boost::posix_time::ptime > registered_type_;

    static registered_type_ registered;

    // password
    //
    typedef odb::query_column< ::std::string > password_type_;

    static password_type_ password;

    // level
    //
    typedef odb::query_column< short unsigned int > level_type_;

    static level_type_ level;

    // backup_email
    //
    typedef odb::query_column< ::std::basic_string< char > > backup_email_type_;

    static backup_email_type_ backup_email;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::id_type_
  query_columns< ::Alarmud::user, id_common, A >::id;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::login_type_
  query_columns< ::Alarmud::user, id_common, A >::login;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::nickname_type_
  query_columns< ::Alarmud::user, id_common, A >::nickname;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::email_type_
  query_columns< ::Alarmud::user, id_common, A >::email;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::registered_type_
  query_columns< ::Alarmud::user, id_common, A >::registered;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::password_type_
  query_columns< ::Alarmud::user, id_common, A >::password;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::level_type_
  query_columns< ::Alarmud::user, id_common, A >::level;

  template <typename A>
  typename query_columns< ::Alarmud::user, id_common, A >::backup_email_type_
  query_columns< ::Alarmud::user, id_common, A >::backup_email;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::Alarmud::user, id_common, A >:
    query_columns< ::Alarmud::user, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Alarmud::user, id_common >:
    public access::object_traits< ::Alarmud::user >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
      odb::details::shared_ptr<prepared_query_impl> (*prepare_query) (connection&, const char*, const query_base_type&);
      odb::details::shared_ptr<result_impl> (*execute_query) (prepared_query_impl&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  // legacy
  //
  template <>
  struct class_traits< ::Alarmud::legacy >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::Alarmud::legacy >
  {
    public:
    typedef ::Alarmud::legacy object_type;
    typedef ::boost::shared_ptr< ::Alarmud::legacy > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef ::std::string id_type;

    static const bool auto_id = false;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::Alarmud::legacy, id_common, A >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // realname
    //
    typedef odb::query_column< ::std::string > realname_type_;

    static realname_type_ realname;

    // email1
    //
    typedef odb::query_column< ::std::string > email1_type_;

    static email1_type_ email1;

    // email2
    //
    typedef odb::query_column< ::std::string > email2_type_;

    static email2_type_ email2;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::Alarmud::legacy, id_common, A >::name_type_
  query_columns< ::Alarmud::legacy, id_common, A >::name;

  template <typename A>
  typename query_columns< ::Alarmud::legacy, id_common, A >::realname_type_
  query_columns< ::Alarmud::legacy, id_common, A >::realname;

  template <typename A>
  typename query_columns< ::Alarmud::legacy, id_common, A >::email1_type_
  query_columns< ::Alarmud::legacy, id_common, A >::email1;

  template <typename A>
  typename query_columns< ::Alarmud::legacy, id_common, A >::email2_type_
  query_columns< ::Alarmud::legacy, id_common, A >::email2;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::Alarmud::legacy, id_common, A >:
    query_columns< ::Alarmud::legacy, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::Alarmud::legacy, id_common >:
    public access::object_traits< ::Alarmud::legacy >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, const object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
      odb::details::shared_ptr<prepared_query_impl> (*prepare_query) (connection&, const char*, const query_base_type&);
      odb::details::shared_ptr<result_impl> (*execute_query) (prepared_query_impl&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static odb::details::shared_ptr<prepared_query_impl>
    prepare_query (connection&, const char*, const query_base_type&);

    static odb::details::shared_ptr<result_impl>
    execute_query (prepared_query_impl&);
  };

  // toonExtra
  //
  // toonRent
  //
  // toonBank
  //
  // toon
  //
  template <>
  struct alias_traits<
    ::Alarmud::toonExtra,
    id_common,
    access::object_traits_impl< ::Alarmud::toon, id_common >::data_tag>
  {
  };

  template <>
  struct query_columns_base< ::Alarmud::toon, id_common >
  {
    // data
    //
    typedef
    odb::alias_traits<
      ::Alarmud::toonExtra,
      id_common,
      access::object_traits_impl< ::Alarmud::toon, id_common >::data_tag>
    data_alias_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::Alarmud::toonExtra,
        id_common,
        data_alias_ > >
    data_type_ ;

    static data_type_ data;
  };

  template <typename A>
  struct query_columns< ::Alarmud::toon, id_common, A >:
    query_columns_base< ::Alarmud::toon, id_common >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // password
    //
    typedef odb::query_column< ::std::string > password_type_;

    static password_type_ password;

    // title
    //
    typedef odb::query_column< ::std::string > title_type_;

    static title_type_ title;

    // lastlogin
    //
    typedef odb::query_column< ::boost::posix_time::ptime > lastlogin_type_;

    static lastlogin_type_ lastlogin;

    // owner_id
    //
    typedef odb::query_column< long long unsigned int > owner_id_type_;

    static owner_id_type_ owner_id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::Alarmud::toon, id_common, A >::name_type_
  query_columns< ::Alarmud::toon, id_common, A >::name;

  template <typename A>
  typename query_columns< ::Alarmud::toon, id_common, A >::password_type_
  query_columns< ::Alarmud::toon, id_common, A >::password;

  template <typename A>
  typename query_columns< ::Alarmud::toon, id_common, A >::title_type_
  query_columns< ::Alarmud::toon, id_common, A >::title;

  template <typename A>
  typename query_columns< ::Alarmud::toon, id_common, A >::lastlogin_type_
  query_columns< ::Alarmud::toon, id_common, A >::lastlogin;

  template <typename A>
  typename query_columns< ::Alarmud::toon, id_common, A >::owner_id_type_
  query_columns< ::Alarmud::toon, id_common, A >::owner_id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // user
  //
  // legacy
  //
}

#include "account-odb.ixx"

#include <odb/post.hxx>

#endif // ACCOUNT_ODB_HXX
